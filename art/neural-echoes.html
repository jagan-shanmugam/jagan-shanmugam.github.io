<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neural Echoes - Interactive Generative Art</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,opsz,wght@0,9..144,300;0,9..144,400;0,9..144,500;0,9..144,600;1,9..144,400&family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Portfolio-matched colors */
      --bg-primary: #0a0908;
      --bg-secondary: #141210;
      --bg-tertiary: #1e1b18;
      --bg-elevated: #262320;

      --text-primary: #f5f4f2;
      --text-secondary: #a8a5a0;
      --text-tertiary: #6b6862;

      --accent-gold: #d4a574;
      --accent-gold-light: #e8c9a8;
      --accent-gold-dim: rgba(212, 165, 116, 0.15);

      --accent-cyan: #7eb8c9;
      --accent-cyan-dim: rgba(126, 184, 201, 0.15);

      --border-color: rgba(255, 255, 255, 0.08);
      --border-hover: rgba(255, 255, 255, 0.15);

      /* Typography */
      --font-display: 'Fraunces', Georgia, serif;
      --font-body: 'Inter', -apple-system, sans-serif;
      --font-mono: 'JetBrains Mono', monospace;

      /* Transitions */
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
      --ease-out-quart: cubic-bezier(0.25, 1, 0.5, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: var(--font-body);
      background: var(--bg-primary);
      color: var(--text-primary);
      -webkit-font-smoothing: antialiased;
    }

    /* Main Layout */
    .neural-app {
      display: flex;
      height: 100vh;
      position: relative;
      overflow: hidden;
    }

    /* Canvas Area - Hero */
    .canvas-stage {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      background:
        radial-gradient(ellipse at 30% 20%, rgba(212, 165, 116, 0.03) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 80%, rgba(126, 184, 201, 0.02) 0%, transparent 50%),
        var(--bg-primary);
    }

    #canvas-container {
      position: relative;
      border-radius: 2px;
      overflow: hidden;
      box-shadow:
        0 0 0 1px var(--border-color),
        0 25px 50px -12px rgba(0, 0, 0, 0.5),
        0 0 100px -20px rgba(212, 165, 116, 0.1);
      transition: box-shadow 0.6s var(--ease-out-expo);
    }

    #canvas-container:hover {
      box-shadow:
        0 0 0 1px var(--border-hover),
        0 25px 50px -12px rgba(0, 0, 0, 0.6),
        0 0 120px -20px rgba(212, 165, 116, 0.15);
    }

    #canvas-container canvas {
      display: block;
    }

    /* Floating Header */
    .floating-header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 32px 40px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
    }

    .title-block {
      opacity: 0;
      animation: fadeSlideDown 0.8s var(--ease-out-expo) 0.2s forwards;
    }

    .title-block h1 {
      font-family: var(--font-display);
      font-size: 28px;
      font-weight: 500;
      letter-spacing: -0.03em;
      color: var(--text-primary);
      margin-bottom: 6px;
      font-variation-settings: 'opsz' 32;
    }

    .title-block .subtitle {
      font-size: 13px;
      color: var(--text-tertiary);
      letter-spacing: 0.02em;
      font-weight: 400;
    }

    /* Seed Display - Floating */
    .seed-badge {
      pointer-events: auto;
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(20, 18, 16, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 10px 16px;
      border-radius: 100px;
      border: 1px solid var(--border-color);
      opacity: 0;
      animation: fadeSlideDown 0.8s var(--ease-out-expo) 0.4s forwards;
    }

    .seed-badge-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-tertiary);
      font-weight: 500;
    }

    .seed-badge-value {
      font-family: var(--font-mono);
      font-size: 14px;
      color: var(--accent-gold);
      font-weight: 500;
    }

    .seed-nav {
      display: flex;
      gap: 4px;
    }

    .seed-nav button {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 1px solid var(--border-color);
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s var(--ease-out-quart);
      font-size: 14px;
    }

    .seed-nav button:hover {
      background: var(--accent-gold-dim);
      border-color: var(--accent-gold);
      color: var(--accent-gold);
    }

    /* Control Panel */
    .control-panel {
      width: 340px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      transform: translateX(0);
      transition: transform 0.5s var(--ease-out-expo), width 0.5s var(--ease-out-expo);
      overflow: hidden;
    }

    .control-panel.collapsed {
      width: 0;
      transform: translateX(340px);
    }

    .panel-toggle {
      position: absolute;
      right: 340px;
      top: 50%;
      transform: translateY(-50%);
      width: 24px;
      height: 64px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-tertiary);
      transition: all 0.3s var(--ease-out-quart);
      z-index: 20;
    }

    .control-panel.collapsed + .canvas-stage .panel-toggle,
    .panel-toggle.shifted {
      right: 0;
    }

    .panel-toggle:hover {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
    }

    .panel-toggle svg {
      width: 14px;
      height: 14px;
      transition: transform 0.3s var(--ease-out-quart);
    }

    .control-panel.collapsed ~ .panel-toggle svg {
      transform: rotate(180deg);
    }

    /* Panel Content */
    .panel-scroll {
      flex: 1;
      overflow-y: auto;
      padding: 28px 24px;
    }

    .panel-scroll::-webkit-scrollbar {
      width: 6px;
    }

    .panel-scroll::-webkit-scrollbar-track {
      background: transparent;
    }

    .panel-scroll::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 3px;
    }

    /* Control Sections */
    .control-section {
      margin-bottom: 32px;
    }

    .control-section:last-child {
      margin-bottom: 0;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .section-icon {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: var(--accent-gold-dim);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent-gold);
      font-size: 14px;
    }

    .section-icon.cyan {
      background: var(--accent-cyan-dim);
      color: var(--accent-cyan);
    }

    .section-title {
      font-family: var(--font-display);
      font-size: 15px;
      font-weight: 500;
      color: var(--text-primary);
      letter-spacing: -0.01em;
    }

    /* Sliders */
    .control-row {
      margin-bottom: 20px;
    }

    .control-row:last-child {
      margin-bottom: 0;
    }

    .control-label {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 10px;
    }

    .control-label span {
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 400;
    }

    .control-value {
      font-family: var(--font-mono);
      font-size: 12px;
      color: var(--accent-gold);
      background: var(--accent-gold-dim);
      padding: 2px 8px;
      border-radius: 4px;
    }

    .slider-track {
      position: relative;
      height: 6px;
      background: var(--bg-tertiary);
      border-radius: 3px;
      cursor: pointer;
    }

    .slider-track input[type="range"] {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
      margin: 0;
    }

    .slider-fill {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, var(--accent-gold), var(--accent-gold-light));
      border-radius: 3px;
      pointer-events: none;
      transition: width 0.1s ease-out;
    }

    .slider-thumb {
      position: absolute;
      top: 50%;
      width: 16px;
      height: 16px;
      background: var(--text-primary);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: transform 0.15s var(--ease-out-quart);
    }

    .slider-track:hover .slider-thumb {
      transform: translate(-50%, -50%) scale(1.15);
    }

    /* Presets */
    .presets-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .preset-btn {
      padding: 10px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s var(--ease-out-quart);
      text-align: center;
    }

    .preset-btn:hover {
      background: var(--accent-gold-dim);
      border-color: var(--accent-gold);
      color: var(--accent-gold);
    }

    .preset-btn.active {
      background: var(--accent-gold);
      border-color: var(--accent-gold);
      color: var(--bg-primary);
    }

    /* Action Buttons */
    .actions-row {
      display: flex;
      gap: 10px;
      padding: 20px 24px;
      border-top: 1px solid var(--border-color);
      background: var(--bg-tertiary);
    }

    .action-btn {
      flex: 1;
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: transparent;
      color: var(--text-secondary);
      font-family: var(--font-body);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s var(--ease-out-quart);
    }

    .action-btn:hover {
      background: var(--bg-elevated);
      border-color: var(--border-hover);
      color: var(--text-primary);
    }

    .action-btn.primary {
      background: var(--accent-gold);
      border-color: var(--accent-gold);
      color: var(--bg-primary);
    }

    .action-btn.primary:hover {
      background: var(--accent-gold-light);
      border-color: var(--accent-gold-light);
    }

    /* Loading State */
    .loading-overlay {
      position: absolute;
      inset: 0;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      z-index: 100;
      transition: opacity 0.5s var(--ease-out-expo);
    }

    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 2px solid var(--border-color);
      border-top-color: var(--accent-gold);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .loading-text {
      font-size: 13px;
      color: var(--text-tertiary);
      letter-spacing: 0.05em;
    }

    /* Animations */
    @keyframes fadeSlideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Responsive */
    @media (max-width: 900px) {
      .control-panel {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        z-index: 30;
        box-shadow: -10px 0 40px rgba(0, 0, 0, 0.3);
      }

      .floating-header {
        padding: 20px 24px;
      }

      .title-block h1 {
        font-size: 22px;
      }
    }

    @media (max-width: 600px) {
      .control-panel {
        width: 100%;
      }

      .control-panel.collapsed {
        transform: translateX(100%);
      }

      .seed-badge {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="neural-app">
    <!-- Canvas Stage -->
    <div class="canvas-stage">
      <div class="floating-header">
        <div class="title-block">
          <h1>Neural Echoes</h1>
          <p class="subtitle">Visualizing thought architecture</p>
        </div>

        <div class="seed-badge">
          <span class="seed-badge-label">Seed</span>
          <span class="seed-badge-value" id="seed-display">42</span>
          <div class="seed-nav">
            <button onclick="previousSeed()" title="Previous">&#8249;</button>
            <button onclick="nextSeed()" title="Next">&#8250;</button>
            <button onclick="randomSeedAndUpdate()" title="Random">&#8635;</button>
          </div>
        </div>
      </div>

      <div id="canvas-container"></div>

      <div class="loading-overlay" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Initializing neural network</div>
      </div>

      <button class="panel-toggle" id="panel-toggle" onclick="togglePanel()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M9 18l6-6-6-6"/>
        </svg>
      </button>
    </div>

    <!-- Control Panel -->
    <div class="control-panel" id="control-panel">
      <div class="panel-scroll">

        <!-- Network Section -->
        <div class="control-section">
          <div class="section-header">
            <div class="section-icon">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/><circle cx="4" cy="6" r="2"/><circle cx="20" cy="6" r="2"/>
                <circle cx="4" cy="18" r="2"/><circle cx="20" cy="18" r="2"/>
                <path d="M6 7l4 4M14 11l4-4M6 17l4-4M14 13l4 4"/>
              </svg>
            </div>
            <h3 class="section-title">Network</h3>
          </div>

          <div class="control-row">
            <div class="control-label">
              <span>Nodes</span>
              <span class="control-value" id="nodeCount-value">150</span>
            </div>
            <div class="slider-track">
              <input type="range" id="nodeCount" min="50" max="300" step="10" value="150"
                     oninput="updateSlider('nodeCount', this.value)">
              <div class="slider-fill" id="nodeCount-fill" style="width: 40%"></div>
              <div class="slider-thumb" id="nodeCount-thumb" style="left: 40%"></div>
            </div>
          </div>

          <div class="control-row">
            <div class="control-label">
              <span>Density</span>
              <span class="control-value" id="connectionDensity-value">0.06</span>
            </div>
            <div class="slider-track">
              <input type="range" id="connectionDensity" min="0.02" max="0.15" step="0.01" value="0.06"
                     oninput="updateSlider('connectionDensity', this.value)">
              <div class="slider-fill" id="connectionDensity-fill" style="width: 31%"></div>
              <div class="slider-thumb" id="connectionDensity-thumb" style="left: 31%"></div>
            </div>
          </div>

          <div class="control-row">
            <div class="control-label">
              <span>Layers</span>
              <span class="control-value" id="layerCount-value">5</span>
            </div>
            <div class="slider-track">
              <input type="range" id="layerCount" min="3" max="8" step="1" value="5"
                     oninput="updateSlider('layerCount', this.value)">
              <div class="slider-fill" id="layerCount-fill" style="width: 40%"></div>
              <div class="slider-thumb" id="layerCount-thumb" style="left: 40%"></div>
            </div>
          </div>
        </div>

        <!-- Dynamics Section -->
        <div class="control-section">
          <div class="section-header">
            <div class="section-icon cyan">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
              </svg>
            </div>
            <h3 class="section-title">Dynamics</h3>
          </div>

          <div class="control-row">
            <div class="control-label">
              <span>Signal Speed</span>
              <span class="control-value" id="signalSpeed-value">1.5</span>
            </div>
            <div class="slider-track">
              <input type="range" id="signalSpeed" min="0.5" max="3" step="0.1" value="1.5"
                     oninput="updateSlider('signalSpeed', this.value)">
              <div class="slider-fill" id="signalSpeed-fill" style="width: 40%"></div>
              <div class="slider-thumb" id="signalSpeed-thumb" style="left: 40%"></div>
            </div>
          </div>

          <div class="control-row">
            <div class="control-label">
              <span>Pulse Rate</span>
              <span class="control-value" id="pulseFrequency-value">2</span>
            </div>
            <div class="slider-track">
              <input type="range" id="pulseFrequency" min="0.5" max="5" step="0.5" value="2"
                     oninput="updateSlider('pulseFrequency', this.value)">
              <div class="slider-fill" id="pulseFrequency-fill" style="width: 33%"></div>
              <div class="slider-thumb" id="pulseFrequency-thumb" style="left: 33%"></div>
            </div>
          </div>
        </div>

        <!-- Presets Section -->
        <div class="control-section">
          <div class="section-header">
            <div class="section-icon">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/>
                <rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/>
              </svg>
            </div>
            <h3 class="section-title">Presets</h3>
          </div>

          <div class="presets-grid">
            <button class="preset-btn" onclick="applyPreset('minimal')">Minimal</button>
            <button class="preset-btn active" onclick="applyPreset('balanced')">Balanced</button>
            <button class="preset-btn" onclick="applyPreset('dense')">Dense</button>
            <button class="preset-btn" onclick="applyPreset('fast')">Fast</button>
            <button class="preset-btn" onclick="applyPreset('deep')">Deep</button>
            <button class="preset-btn" onclick="applyPreset('chaos')">Chaos</button>
          </div>
        </div>

      </div>

      <!-- Actions -->
      <div class="actions-row">
        <button class="action-btn" onclick="resetParameters()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
            <path d="M3 3v5h5"/>
          </svg>
          Reset
        </button>
        <button class="action-btn primary" onclick="downloadArt()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7,10 12,15 17,10"/><line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
          Download
        </button>
      </div>
    </div>
  </div>

  <script>
    // ═══════════════════════════════════════════════════════════════════════
    // NEURAL ECHOES - REFINED PARAMETERS
    // ═══════════════════════════════════════════════════════════════════════

    let params = {
      seed: 42,
      nodeCount: 150,
      connectionDensity: 0.06,
      signalSpeed: 1.5,
      pulseFrequency: 2,
      layerCount: 5,
      colorActivation: '#d4a574',
      colorInhibition: '#7eb8c9',
      colorBackground: '#0a0908'
    };

    let defaultParams = {...params};

    const presets = {
      minimal: { nodeCount: 80, connectionDensity: 0.03, layerCount: 4, signalSpeed: 1, pulseFrequency: 1 },
      balanced: { nodeCount: 150, connectionDensity: 0.06, layerCount: 5, signalSpeed: 1.5, pulseFrequency: 2 },
      dense: { nodeCount: 250, connectionDensity: 0.12, layerCount: 6, signalSpeed: 1.2, pulseFrequency: 2.5 },
      fast: { nodeCount: 120, connectionDensity: 0.05, layerCount: 5, signalSpeed: 2.5, pulseFrequency: 4 },
      deep: { nodeCount: 200, connectionDensity: 0.08, layerCount: 8, signalSpeed: 1, pulseFrequency: 1.5 },
      chaos: { nodeCount: 300, connectionDensity: 0.15, layerCount: 7, signalSpeed: 2, pulseFrequency: 5 }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // NEURAL NETWORK VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    let nodes = [];
    let connections = [];
    let signals = [];
    let time = 0;
    let canvasSize;

    function setup() {
      // Calculate canvas size based on viewport
      const stage = document.querySelector('.canvas-stage');
      const maxSize = Math.min(stage.clientWidth - 80, stage.clientHeight - 120, 900);
      canvasSize = Math.max(500, maxSize);

      let canvas = createCanvas(canvasSize, canvasSize);
      canvas.parent('canvas-container');
      pixelDensity(2);

      initializeSystem();

      // Hide loading
      setTimeout(() => {
        document.getElementById('loading').classList.add('hidden');
      }, 500);
    }

    function windowResized() {
      const stage = document.querySelector('.canvas-stage');
      const maxSize = Math.min(stage.clientWidth - 80, stage.clientHeight - 120, 900);
      canvasSize = Math.max(500, maxSize);
      resizeCanvas(canvasSize, canvasSize);
      initializeSystem();
    }

    function initializeSystem() {
      randomSeed(params.seed);
      noiseSeed(params.seed);

      nodes = [];
      connections = [];
      signals = [];
      time = 0;

      // Create nodes in layers
      let layerWidth = width / (params.layerCount + 1);
      let nodesPerLayer = Math.floor(params.nodeCount / params.layerCount);

      for (let layer = 0; layer < params.layerCount; layer++) {
        let layerX = layerWidth * (layer + 1);
        let layerNodeCount = layer === 0 || layer === params.layerCount - 1
          ? Math.floor(nodesPerLayer * 0.6)
          : nodesPerLayer + Math.floor(random(-5, 5));

        for (let i = 0; i < layerNodeCount; i++) {
          let spacing = height / (layerNodeCount + 1);
          let baseY = spacing * (i + 1);

          let offsetX = random(-layerWidth * 0.2, layerWidth * 0.2);
          let offsetY = random(-spacing * 0.3, spacing * 0.3);

          nodes.push(new Node(
            layerX + offsetX,
            baseY + offsetY,
            layer,
            random(2.5, 6)
          ));
        }
      }

      // Create weighted connections
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          let nodeA = nodes[i];
          let nodeB = nodes[j];

          let layerDiff = Math.abs(nodeA.layer - nodeB.layer);
          if (layerDiff > 2) continue;

          let distance = dist(nodeA.x, nodeA.y, nodeB.x, nodeB.y);
          let maxDist = layerWidth * 2;

          let prob = params.connectionDensity * (1 - distance / maxDist);
          if (layerDiff === 1) prob *= 2;

          if (random() < prob && distance < maxDist) {
            let weight = random(0.3, 1);
            let isInhibitory = random() < 0.2;
            connections.push(new Connection(nodeA, nodeB, weight, isInhibitory));
          }
        }
      }

      background(params.colorBackground);
    }

    function draw() {
      // Semi-transparent background for trails
      let bgColor = color(params.colorBackground);
      bgColor.setAlpha(18);
      background(bgColor);

      time += 0.016;

      // Spawn signals
      if (frameCount % Math.floor(60 / params.pulseFrequency) === 0) {
        let inputNodes = nodes.filter(n => n.layer === 0);
        if (inputNodes.length > 0) {
          let startNode = random(inputNodes);
          signals.push(new Signal(startNode, random(0.5, 1)));
        }
      }

      // Draw connections
      for (let conn of connections) {
        conn.draw();
      }

      // Update and draw signals
      for (let i = signals.length - 1; i >= 0; i--) {
        signals[i].update();
        signals[i].draw();
        if (signals[i].isDead()) signals.splice(i, 1);
      }

      // Draw nodes
      for (let node of nodes) {
        node.update();
        node.draw();
      }

      // Subtle film grain
      if (frameCount % 2 === 0) {
        loadPixels();
        for (let i = 0; i < pixels.length; i += 4) {
          let noiseVal = random(-2, 2);
          pixels[i] = constrain(pixels[i] + noiseVal, 0, 255);
          pixels[i + 1] = constrain(pixels[i + 1] + noiseVal, 0, 255);
          pixels[i + 2] = constrain(pixels[i + 2] + noiseVal, 0, 255);
        }
        updatePixels();
      }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE CLASS
    // ═══════════════════════════════════════════════════════════════════════

    class Node {
      constructor(x, y, layer, size) {
        this.x = x;
        this.y = y;
        this.layer = layer;
        this.baseSize = size;
        this.size = size;
        this.activation = 0;
        this.phase = random(TWO_PI);
      }

      activate(amount) {
        this.activation = min(this.activation + amount, 1);
      }

      update() {
        this.activation *= 0.94;
        this.size = this.baseSize + sin(time * 2 + this.phase) * 0.4;
      }

      draw() {
        let activationColor = color(params.colorActivation);
        let inhibitionColor = color(params.colorInhibition);
        let layerRatio = this.layer / (params.layerCount - 1);
        let baseColor = lerpColor(inhibitionColor, activationColor, layerRatio);

        // Glow
        if (this.activation > 0.1) {
          let glowSize = this.size * (2 + this.activation * 4);
          let glowColor = color(baseColor.toString());
          glowColor.setAlpha(this.activation * 40);
          noStroke();
          for (let i = 3; i > 0; i--) {
            fill(glowColor);
            ellipse(this.x, this.y, glowSize * i / 3);
            glowColor.setAlpha(glowColor._getAlpha() * 0.5);
          }
        }

        // Core
        let coreAlpha = 120 + this.activation * 135;
        baseColor.setAlpha(coreAlpha);
        fill(baseColor);
        noStroke();
        ellipse(this.x, this.y, this.size);

        // Center highlight
        fill(255, 255, 255, 40 + this.activation * 120);
        ellipse(this.x, this.y, this.size * 0.35);
      }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONNECTION CLASS
    // ═══════════════════════════════════════════════════════════════════════

    class Connection {
      constructor(nodeA, nodeB, weight, isInhibitory) {
        this.nodeA = nodeA;
        this.nodeB = nodeB;
        this.weight = weight;
        this.isInhibitory = isInhibitory;
        this.activity = 0;
      }

      activate() {
        this.activity = 1;
      }

      draw() {
        this.activity *= 0.91;

        let baseAlpha = 8 + this.weight * 15 + this.activity * 70;
        let col = this.isInhibitory
          ? color(params.colorInhibition)
          : color(params.colorActivation);

        col.setAlpha(baseAlpha);
        stroke(col);
        strokeWeight(0.4 + this.weight * 1.2 + this.activity * 2);

        let midX = (this.nodeA.x + this.nodeB.x) / 2;
        let midY = (this.nodeA.y + this.nodeB.y) / 2;
        let offset = (this.nodeB.layer - this.nodeA.layer) * 15;

        noFill();
        bezier(
          this.nodeA.x, this.nodeA.y,
          midX + offset, midY - offset,
          midX - offset, midY + offset,
          this.nodeB.x, this.nodeB.y
        );
      }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SIGNAL CLASS
    // ═══════════════════════════════════════════════════════════════════════

    class Signal {
      constructor(startNode, strength) {
        this.currentNode = startNode;
        this.strength = strength;
        this.life = 1;
        this.visitedNodes = new Set([startNode]);
        this.x = startNode.x;
        this.y = startNode.y;
        this.targetNode = null;
        this.progress = 1;
        this.trail = [];

        startNode.activate(strength);
        this.findNextTarget();
      }

      findNextTarget() {
        let possibleConnections = connections.filter(c =>
          (c.nodeA === this.currentNode || c.nodeB === this.currentNode) &&
          !this.visitedNodes.has(c.nodeA === this.currentNode ? c.nodeB : c.nodeA)
        );

        if (possibleConnections.length === 0) {
          this.life = 0;
          return;
        }

        let totalWeight = possibleConnections.reduce((sum, c) => sum + c.weight, 0);
        let r = random(totalWeight);
        let cumulative = 0;

        for (let conn of possibleConnections) {
          cumulative += conn.weight;
          if (r <= cumulative) {
            this.targetNode = conn.nodeA === this.currentNode ? conn.nodeB : conn.nodeA;
            conn.activate();
            if (conn.isInhibitory) this.strength *= 0.5;
            break;
          }
        }
        this.progress = 0;
      }

      update() {
        if (!this.targetNode) return;

        this.progress += 0.02 * params.signalSpeed;
        let t = this.easeInOutCubic(this.progress);
        this.x = lerp(this.currentNode.x, this.targetNode.x, t);
        this.y = lerp(this.currentNode.y, this.targetNode.y, t);

        this.trail.push({x: this.x, y: this.y, age: 0});

        for (let i = this.trail.length - 1; i >= 0; i--) {
          this.trail[i].age += 0.05;
          if (this.trail[i].age > 1) this.trail.splice(i, 1);
        }

        if (this.progress >= 1) {
          this.currentNode = this.targetNode;
          this.visitedNodes.add(this.currentNode);
          this.currentNode.activate(this.strength);
          this.strength *= 0.85;
          this.life -= 0.1;

          if (this.strength < 0.1 || this.life <= 0) {
            this.life = 0;
          } else {
            this.findNextTarget();
          }
        }
      }

      easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      draw() {
        noFill();
        for (let i = 0; i < this.trail.length - 1; i++) {
          let p = this.trail[i];
          let alpha = (1 - p.age) * this.strength * 180;
          let col = color(params.colorActivation);
          col.setAlpha(alpha);
          stroke(col);
          strokeWeight((1 - p.age) * 3.5 * this.strength);

          if (i < this.trail.length - 1) {
            let next = this.trail[i + 1];
            line(p.x, p.y, next.x, next.y);
          }
        }

        let headSize = 5 + this.strength * 10;
        let col = color(params.colorActivation);

        for (let i = 3; i > 0; i--) {
          col.setAlpha(this.strength * 35 * i);
          fill(col);
          noStroke();
          ellipse(this.x, this.y, headSize * i);
        }

        fill(255, 255, 255, this.strength * 220);
        ellipse(this.x, this.y, headSize * 0.45);
      }

      isDead() { return this.life <= 0; }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UI HANDLERS
    // ═══════════════════════════════════════════════════════════════════════

    function updateSlider(paramName, value) {
      params[paramName] = parseFloat(value);
      document.getElementById(paramName + '-value').textContent = value;

      // Update slider visual
      const slider = document.getElementById(paramName);
      const min = parseFloat(slider.min);
      const max = parseFloat(slider.max);
      const percent = ((value - min) / (max - min)) * 100;

      document.getElementById(paramName + '-fill').style.width = percent + '%';
      document.getElementById(paramName + '-thumb').style.left = percent + '%';

      initializeSystem();
    }

    function applyPreset(name) {
      const preset = presets[name];
      if (!preset) return;

      // Update buttons
      document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');

      // Apply preset values
      for (let key in preset) {
        params[key] = preset[key];
        const slider = document.getElementById(key);
        if (slider) {
          slider.value = preset[key];
          updateSlider(key, preset[key]);
        }
      }
    }

    function togglePanel() {
      const panel = document.getElementById('control-panel');
      const toggle = document.getElementById('panel-toggle');
      panel.classList.toggle('collapsed');
      toggle.classList.toggle('shifted');

      // Resize canvas after panel animation
      setTimeout(windowResized, 550);
    }

    function updateSeedDisplay() {
      document.getElementById('seed-display').textContent = params.seed;
    }

    function previousSeed() {
      params.seed = Math.max(1, params.seed - 1);
      updateSeedDisplay();
      initializeSystem();
    }

    function nextSeed() {
      params.seed++;
      updateSeedDisplay();
      initializeSystem();
    }

    function randomSeedAndUpdate() {
      params.seed = Math.floor(Math.random() * 999999) + 1;
      updateSeedDisplay();
      initializeSystem();
    }

    function resetParameters() {
      params = {...defaultParams};

      // Reset all sliders
      for (let key of ['nodeCount', 'connectionDensity', 'layerCount', 'signalSpeed', 'pulseFrequency']) {
        const slider = document.getElementById(key);
        if (slider) {
          slider.value = params[key];
          updateSlider(key, params[key]);
        }
      }

      // Reset preset buttons
      document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelector('.preset-btn:nth-child(2)').classList.add('active');

      updateSeedDisplay();
      initializeSystem();
    }

    function downloadArt() {
      saveCanvas('neural-echoes-' + params.seed, 'png');
    }

    // Initialize
    window.addEventListener('load', () => {
      updateSeedDisplay();

      // Initialize slider visuals
      for (let key of ['nodeCount', 'connectionDensity', 'layerCount', 'signalSpeed', 'pulseFrequency']) {
        const slider = document.getElementById(key);
        if (slider) {
          const min = parseFloat(slider.min);
          const max = parseFloat(slider.max);
          const value = parseFloat(slider.value);
          const percent = ((value - min) / (max - min)) * 100;
          document.getElementById(key + '-fill').style.width = percent + '%';
          document.getElementById(key + '-thumb').style.left = percent + '%';
        }
      }
    });
  </script>
</body>
</html>
